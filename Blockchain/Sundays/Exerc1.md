contracts - > тук са ни всичките контракти
remix -> remix.ethereum.org
Поддържа solidity тестове и   javascript тестове
Front-end(angular)
Web.js(прави връзка между контракта и фронт-енда на частта)
Smart contract
Solidity Code
EVM(virtual machine)
Node(всички участници в мрежата)
Цялото това нещо отгоре е DAPP(decentralized app)-> от фронт енда до ноде
Всичко се пази,понеже е в клауда.Ако си изтрием кеша се маха.
ipfs - > файлова система , която не е централизирана


code:
pragma solidity - > указва версията на компилатора,  с който искаме да се изпълни кода
//SPDX-License.. -> лиценз на смарт контракта(и това е задължително)
GPL-3.0 open source лицензе
Solitidy - език от високо ниво
pragm solidity - > горе долу 2 големи версии нодалу
това което напишем след contract Storage се нарича state field -> всичко тук в storage
Camel_case,Pascal Case
модификаторите на достъп се пишат след това, и върнатиш резултат след това
truffle - за големи проекти
hardhat - > за малки проекти
wallet - > metamask
ganache - > симулация на блокчейн
почти никъде не се ползват стрингове
map -> ключовере най-вече са адреси и числа
Access modifiers:
Internal - > като protected(когато наследяваме само наследниците и вътре може)
External - > може само от друг смарт контракт да се използва например
Compiler modifiers:
View -> това май е като константна функция(може само да чете state-field-овете)
Pure -> тя нито може да чете в леджера, нито да пише в него (ползва се най-често за изчисление, или примерно някой иска да ползва смарт контракта, и смарт контракта проверява дали този адрес има право на достъп до самия смарт контракт.С други думи прави проверка или някво изчисление)
Има начин да кажем дали една променлива е  в рамта или в стейт-а
Payable -> тя може да получава като крипто,иначе компилатора не позволява транзакцията
Constant (*Провери това с C++ какво беше)-> 
добра практика е да се слага _ на аргументи
всяка транзакция си има уникално ид,това ид като се хешираа се получава хеш ид
реално smartcontract-a е като транзакция в ledger-а  -> и има адрес на който ние можем да интерактваме с ledger-а
***протокол***
ethereum yellow paper - >описва техническата част на нещо как работи(ethereum yellow paper)
appendix g. fee schedule
 
3 теста от по 10 въпроса
и проект, който е от няколко домашни
в солидити примерно ако имаме мап от адрес към потребител, тр да имаме и масив с всички адреси,защото не можем да итерираме през мап
масивите са динамични само в стейтовете,ако го направим в няква фунцкия той няма да бъде динамичен
msg.sender -
docs.solititylang.org§: 

