
ZAD 86 2020-SE-03
tva 573b e 16tichno chislo
Писането към тръба , а и не само е защите от мутекс
XOR е комутативна операция - > няма значение реда по който се подават, резултатът е един и съш
Ако 2ма искат да запишат нешо в тръбата , то първия стигнал ще пише първи.Няма да им се омешат write-тите
No - > tva znachi che offseta e ot 0 do bezkrainost(0 e purviq element,vse edno indiksirame masiv)
Да не излизаме извън края на файловата 
edin write e po-dobur ot mnogo write-ove
padding->
when do we have a problem with padding - > look that up
struct __attribute__ ((packed)) triplet{

};
Веднага щом има нещо за четене родителя си го чете, тоест read от пайп няма нужда да чака всички write части да бъдат затворени
преди да започне да чете
Изкарване на логиката във функции -  > по-удобно за намиране на грешки
Когато С тръгне да изпълнява код и трябва да позициобира тази структура в рамта ще я позиционира без да слага паддинг
printf ne e pozvoleno , dprintf e pozvoleno
zadachata e v C-paren
read poluchava uf kogato vsichki deca si zatvorqt trubite

int main(int argc, char ** argv){
    if(argc!=2){
        errx(1,"wrong arg count!");
    }
    int pipds[2];
    pipe(pipds);
    if(pipds[0] == -1 || pipids[1] == -1){
        err(2,"Pipe couldnt init!")
    }
    int main_fd = open(argv[1],)

}

Погледни пайп как работи отново - > като четем от пайп не е нужно всички крайща да са затворени - > затварянето е само за да имаме някъв енд оф файл


zad 88 2022-IN-01
пайп и пишем към тръбата
детето реадва от тръбата и когато го прочете принтим донг

използваме read  и write A
родител пише ,дете чака да получи нещо
в момента в който детето получи това нещо значи родителя е приклщчил и той пише донг
дететро тр да каже на родителя че е готов с работата си - > и ни трябва втора тръба



zad 89 2023-IN-01
синхронизация с тръби
единия процес като прикл съобщава на другия чрез някаква тръба че е приключил на другия
xnt ppids[NC_MAX][2];
Родителя прави всички деца и всички тръби
Тази ще е като 2ра задача на изпита



зад 72 2021-SE-01
zeromask = 0000 0000 0000 0001
onemask = 0000 0000 0000 0010
трябва ни маска за тоази задача
   mask                    byte            Result
1000 0000          orig=  1011 0110      0000 0000 0000 0000
                          1              0000 0000 0000 0010

                                        
mask >> 1               ORIG&mask       r = (r<<2) | zeromask
0100 0000                 0

>>1
0010 0000                        ORIG&mask      r  = (r<<2) | onemask



Обратната задача сега

1001 1010 0110 1001     Result
1000 0000 0000 0000     1 w nachaloto
0010 0000 0000 0000     10
0000 1000 0000 0000     101
0000 0010 0000 0000     1010


