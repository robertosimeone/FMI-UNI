За C трябва да знаем
tar --help | head -n 10
tar -cf archieve.tar file 1 file 2
tar -xf archieve.tar - > razarhiwira


Компресираме
xz temp.tar 


За удобство:

man bash  - > /case(switch case)
case използва globbing


read e вградена команва вътре в баш
read --help(Ще излезе информация за read-a, който реално използва баш)
Как се чете от стандартния вход в shell
read -p "Name:" Name
echo "Hello, $Name"


while read X Y Z;do
    echo ..
done
(Това което ще стане тук  е че скрипта ще чете от стандартния си вход , тъй като read-a не сме му казали  <<)(Ctr+D все едно му казваме end of file)
read_2.sh < vectors.txt

man 3 mkfifo
Създава файл от тип наименована тръба

mkfifo("name",S_IRWXU);
int fd = open("name",O_WRONLY)
write(fd,"asd",3)
write в момента е блокирал,защото няма никой който да чете
При неименованите тръби write-рите не блокират
При наименованите тръби write-рите блокират ако няма кой да чете


Задача : 83. 2019-SE-01

скица:

while !condition:
    timeS = time(Null)
    start(Q)
    timeE = time(Null)


int counter = 0 ;
bool cond(timeS,timeE,code){
    if(code!=0 and timeE-timeS < th){
        if(counter == 1)
            return true;
        else
            counter++
        return false
    }
    else{
        counter = 0;
        return false;
    }
}

man 7 signal

Използваме dprintf за писането към файла защото иначе ше пишем байтовете, а не character-ите който байтовете репрезентират




strtol - > виж какво един
atoi
Това се използва защото подадените аргументи са стрингове и трябва да ги превърнем към числа
В баш е същото, просто там консрукциятаа [[ test ]] и примерно -eq си го оправя това със стринговете
(конвертира го към инт и после ги сравняв)
В условието просто е казано име не команда , а не оът към команда,затова използваме execlp

има нулл накрая, защото програмата вижда пойнтъри към cstring-ove, затова трябва сда сложим тоя нулл накрая

S_IRWXU - > на изпита трябва да ги орна правнилните иначе се взимат точки


Сега за аргументите на Q - >  execvp
последният аргумент на argv също е терминираща нула, ащото нашата програма също тр да знае колко са и аргументите,
начинът по който го прави това е чрез нуллпойнтера накрая

grep -R - > май рекурсивно грепва по файлове


За тестване - > можем да извикаме sleep за 10 секунди и докато sleepa върви да извикаме kill na sleep-A.И това ако го
направим 2 пъти 
./main 8 false

Задача : 84 2020-SE-01

ako behse normalna truba
cat argv[1]                                         sort
P1                                                  P2
close(pipe[0])                                      close(pipe[1])    
close(1)                                            close(0)
dup(pipe[1])                                        dup(pipe[0])

85 2020-SE-02

Коя команда за четене на файлове да използваме??

Кирилица->cat file
          Output : Кирилица
xxd cat | cut -d '' -f 2-9 | tr -d '\n'
и после strtol - >даваме му каква бройна система е и му казваме че искаме 16тичен вариант
uint16_t b = read(0,2) - > четем 2 байта
swapfunc
long c = strtol(&b,Null,16);
Има един проблем тук байтовете ще са на обратно защото байтовете са на обратно заради endianess-a(в астерото е little endian)

трябва да ги swapнем
Когато се опитваме да четем от файла 2 байта то ги обръща
// след това като сме ги прочели тр да ги запишем в uint16_t и трябва пак да ги обърнем
strtol - > той ще се оправи със обръщането на байтовете, тоест първото нещо, подадено на strotol ще бъде първия read,
а второто ще бъде втория read.

swapfunc(uint16_t *b){
    не може с + щото просто ще го прескочи
    uint8_t *tmp = *(uint8_t * ) b;
    //sega trqbva da swapnem tmp s tmp +1
    uint8_t * tmp1 = *tmp;
    *tmp = *tmp1; 
}
или просто да сменим байтовете да ги прочетем по отделно


cat може да не може да визуализира нещата както трябва - > тоест да има байт който да не може да бъде визуализиран;
ако примерно има само кирилица няма да има проблем, обаче cat може да не може да принтне нещо

За задачата която е със sudo
Да го добавим към path;alias

68.2019-SE-01
16384 означава че още статично може да си заделим
и не повече от 2048
една структура която е това дето е написана и после е направен масив от тази структура
масив users
